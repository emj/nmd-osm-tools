#!/usr/bin/python3

# Process OSM XML obtained from NMD raster data.
# - Replace DN tags with landuse tags
# - Delete ways that do not have associated landuse
# - Fix some known inconsistencies: duplicate notes, repeated nodes
# References:
# - http://www.naturvardsverket.se/Sa-mar-miljon/Kartor/Nationella-Marktackedata-NMD/
# - http://gpt.vic-metria.nu/data/land/NMD/NMD_Produktbeskrivning_NMD2018Basskikt_v1_0.pdf
# - https://lists.openstreetmap.org/pipermail/talk-se/2019-March/003537.html

# Note that when XML items need to be removed it is done in two stages:
# 1. Iterate through all candidates and collect doomed references in a list
# 2. Iterate through that list and remove its items.

# TODO maybe remove ways that have no landuse tags?

import sys
import re
import xml.etree.ElementTree as ET

def usage():
    print("Usage: %s <file.osm>" % sys.argv[0], file = sys.stderr)
    sys.exit(1)

def print_result(tree):
    root = tree.getroot()
    if sys.platform == 'cygwin':
        # work around weird cygwin bug
        print("<?xml version='1.0' encoding='UTF-8'?>")
        sys.stdout.flush()
        ET.dump(root)
    elif sys.platform == 'win32': # TODO not tested
        print("<?xml version='1.0' encoding='UTF-8'?>")
        sys.stdout.flush()
        tree.write(sys.stdout, encoding="utf-8")
    else:
        # Output modified DOM, work around weird python3 bugs
        print("<?xml version='1.0' encoding='UTF-8'?>")
        sys.stdout.flush()
        tree.write("/dev/stdout", encoding="utf-8")

def get_attr_mapper():
    # Return correspondence between "DN" tags generated by QGIS and
    # OSM tags for landuse.

    mapper = dict()
    # Commented are types of landuse not deemed beneficial to trace
    # 1. Water - there are better methods to trace it, also it is already traced
    #    well.
    # 2. For buildings, 10 meters resolution is not enough.
    #    TODO maybe put a single node "building = yes" in the middle of smaller
    #    (4-8 close nodes) ways?
    # 3. Industrial - easier to trace by hand, relatively few places which are
    #    large

    ## 111 Tallskog utanför våtmark
    ## 112 Granskog utanför våtmark
    ## 113 Barrblandskog utanför våtmark
    mapper["111"]={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "needleleaved", "genus": "pinus", "leaf_cycle": "evergreen"}
    mapper["112"]={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "needleleaved", "genus": "picea", "leaf_cycle": "evergreen"}
    mapper["113"]={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "needleleaved", "leaf_cycle": "evergreen"}

    ## 114 Lövblandad barrskog utanför våtmark
    mapper['114']={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "mixed", "leaf_cycle": "mixed"}

    ## 115 Triviallövskog utanför våtmark
    ## 116 Ädellövskog utanför våtmark
    ## 117 Triviallövskog med ädellövinslag utanför våtmark
    mapper['115']={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}
    mapper['116']={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}
    mapper['117']={"source": "NV NMD2018", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}

    ## 118 Temporärt ej skog utanför våtmark
    mapper['118']={"source": "NV NMD2018", "landuse": "forest", "natural": "scrub"}

    ## 121 Tallskog på våtmark
    ## 122 Granskog på våtmark
    ## 123 Barrblandskog på våtmark
    mapper['121']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "needleleaved", "genus": "pinus", "leaf_cycle": "evergreen"}
    mapper['122']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "needleleaved", "genus": "picea", "leaf_cycle": "evergreen"}
    mapper['123']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "needleleaved", "leaf_cycle": "evergreen"}

    ## 124 Lövblandad barrskog på våtmark
    mapper['124']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "mixed", "leaf_cycle": "mixed"}

    ## 125 Triviallövskog på våtmark
    ## 126 Ädellövskog på våtmark
    ## 127 Triviallövskog med ädellövinslag på våtmark
    mapper['125']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}
    mapper['126']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}
    mapper['127']={"source": "NV NMD2018", "natural": "wetland", "landuse": "forest", "leaf_type": "broadleaved", "leaf_cycle": "deciduous"}

    ## 128 Temporärt ej skog på våtmark
    #mapper['128']={"source": "NV NMD2018", "landuse": "forest", "natural": wetland'

    ## 2 Våtmark
    #mapper['2']={"source": "NV NMD2018", "natural": wetland'
    ## 3 Åkermark
    mapper['3']={"source": "NV NMD2018", "landuse": "farmland"}

    ## 41 Övrig öppen mark utan vegetation
    ## 42 Övrig öppen mark med vegetation
    mapper['42']={"source": "NV NMD2018", "landuse": "grass"}

    ## 51 Exploaterad mark, byggnad
    #mapper['51']={"source": "NV NMD2018", "building": "yes", "note": "Needs surveying"}
    ## 52 Exploaterad mark, ej byggnad eller väg/järnväg
    #mapper['52']={"source": "NV NMD2018", "landuse": "industrial", "note": "Needs surveying"}
    ## 53 Exploaterad mark, väg/järnväg

    ## 61 Sjö och vattendrag
    #mapper['61']={"source": "NV NMD2018", "natural": "water"}
    ## 62 Hav
    #mapper['62']={"source": "NV NMD2018", "natural": "water"}
    return mapper


def item_has_k(item, w):
    for tag in item.iter('tag'):
        k = tag.attrib['k']
        if k == w:
            return True
    return False

def replace_tags(root):
    mapper = get_attr_mapper()
    # Nodes do not have tags, but some of the ways have
    for way in root.iter('way'):
        new_tags = dict()
        old_tags = list()
        for tag in way.iter('tag'):
            k = tag.attrib['k']
            v = tag.attrib['v']
            if k == 'DN':
                new_tags = mapper.get(v, dict()) # landuse tags or empty set
            old_tags.append(tag)
        # delete all old tags
        for tag in old_tags:
            way.remove(tag)
        # add new tags
        for key in new_tags.keys():
            ET.SubElement(way, "tag", {"k": key, "v": new_tags[key]})

    # Do the same for relations, but add type=multipolygon as well.
    for rel in root.iter('relation'):
        new_tags = dict()
        old_tags = list()
        for tag in rel.iter('tag'):
            k = tag.attrib['k']
            v = tag.attrib['v']
            if k == 'DN':
                new_tags = mapper.get(v, dict()) # landuse tags or empty set
            old_tags.append(tag)
        # delete all old tags
        for tag in old_tags:
            rel.remove(tag)
        # add new tags
        for key in new_tags.keys():
            ET.SubElement(rel, "tag", {"k": key, "v": new_tags[key]})
        ET.SubElement(rel, "tag", {"k": "type", "v": "multipolygon"})

def mark_unused_items(root):
    # Relations reference ways, ways reference nodes.
    # Keep those items that are either referenced by something or have valuable
    # tags on them.
    referenced_node_ids = set()
    referenced_way_ids = set()

    junk_relations = list()
    junk_ways = list()
    junk_nodes = list()

#    import pdb; pdb.set_trace()
    for rel in root.iter('relation'):
        # Relations are only useful if they have good tags
        rel_useful = item_has_k(rel, 'source')
        if rel_useful:
            for tag in rel.iter('member'):
                #type='way' ref='-1208757'
                assert tag.attrib['type'] == 'way', "Only ways are expected"
                way_ref = int(tag.attrib['ref'])
                referenced_way_ids.add(way_ref)
        else:
            # not found useful tags, mark relation for deletion
            junk_relations.append(rel)

    for way in root.iter('way'):
        way_id = int(way.attrib['id'])
        has_good_tag = item_has_k(way, 'source')
        # Ways are useful if they have good tags or are referenced,
        # otherwise mark them for deletion
        if has_good_tag or (way_id in referenced_way_ids):
            # This way is useful meaning all its nodes are referenced
            for nd in way.iter('nd'):
                nd_ref = int(nd.attrib['ref'])
                referenced_node_ids.add(nd_ref)
        else:
            junk_ways.append(way)

    for node in root.iter('node'):
        node_id = int(node.attrib['id'])
        # Nodes are useful only if they are referenced, no tags on them
        if not node_id in referenced_node_ids:
            junk_nodes.append(node)

    return (junk_relations, junk_ways, junk_nodes)

def find_duplicate_nodes(root, precision = 14):
    duplicate_nodes = list()

    # mapping "coordinates" -> "node id", reverse to what is in input data
    first_coordinates = dict()
    # duplicate node id -> remaining id mapping
    replacement_map = dict() #
    for node in root.iter('node'):
        node_id = int(node.attrib['id'])
        lat = node.attrib['lat']
        lon = node.attrib['lon']

        # Coordinates seem to get rounded, so use only precision digits
        # XXX: not an actual numerical precision but string truncation,
        # still possible to see duplicates later
        latlon = lat[:precision]+lon[:precision] # should be unique enough as a key
        if latlon in first_coordinates:
            # already seen these coordinates, find the replacement
            repl_id = first_coordinates[latlon]
#            print("Replacing duplicate node ref %d with ref %d" %
#                  (node_id, repl_id), file = sys.stderr)
            duplicate_nodes.append(node)
            replacement_map[node_id] = repl_id
        else:
            first_coordinates[latlon] = node_id

    print("Duplicate nodes count: %d" % len(duplicate_nodes), file = sys.stderr)
    return (duplicate_nodes, replacement_map)

def replace_node_ids(root, replacement_map):
    total_id_replaced = 0
    # replace node ids in ways with those in replacement_map
    for way in root.iter('way'):
        for nd in way.iter('nd'):
            nd_ref = int(nd.attrib['ref'])
            if nd_ref in replacement_map:
                new_id = replacement_map[nd_ref]
                total_id_replaced += 1
                nd.attrib['ref'] = str(new_id)
    print("Replaced node ids: %d" % total_id_replaced, file = sys.stderr)

def remove_self_touching_nodes(root):
    # The same node id can happen twice or more times laying on in the same way.
    # It is a warning. Fix it by leaving only one (first) entry for such modes.
    # Exception: first and last nodes may have same id, and are preserved.
    total_duplicates = 0
    for way in root.iter('way'):
        duplicate_entries = list()
        seen_node_refs = set()
        way_id = int(way.attrib['id'])
        # Don't iterate through the last node as it can match
        # the first one for closed ways
        for nd in tuple(way.iter('nd'))[:-1]:
            ref = int(nd.attrib['ref'])
            if ref in seen_node_refs:
                duplicate_entries.append(nd)
            seen_node_refs.add(ref)

        for nd in duplicate_entries:
            way.remove(nd)
        total_duplicates += len(duplicate_entries)
    print("Repeated nodes count: %d" % total_duplicates,
          file = sys.stderr)


def main(argv):
    if len(argv) != 2:
        usage()
    tree = ET.parse(argv[1])
    root = tree.getroot()

    # Stage 1: replace "DN" tags with "landuse" tags, delete ways that are not
    # needed
    replace_tags(root)

    # Stage 2: mark all non-useful relations, ways and nodes.
    (junk_relations, junk_ways, junk_nodes) = mark_unused_items(root)

    # Remove all junk items from previous stage
    for rel in junk_relations:
        root.remove(rel)
    for way in junk_ways:
        root.remove(way)
    for node in junk_nodes:
        root.remove(node)

    # Stage 3: mark short ways for deletion
    # remove nodes that only are in them
    # remove references to them from relations
    # TODO looks logical to make it a part of mark_unused_items()

    # Stage 3.5: merge ways which have identical nodes.
    # It is an frequent situation to have one polygon without tags but with
    # inner role in a multipolygon relation, and another multipolygon with
    # tags but outside any relation and having all its nodes matching. This
    # creates a warning in JOSM. Fix it here, save some manual labor.
    # TODO write me

    # Stage 4: merge all nodes that have same coordinates
    (duplicate_nodes, replacement_map) = find_duplicate_nodes(root)
    for node in duplicate_nodes:
        root.remove(node)
    replace_node_ids(root, replacement_map)

    # Stage 5: remove intersections by removing nodes repeated in the same way
    remove_self_touching_nodes(root)

    print_result(tree)

if __name__ == "__main__":
    sys.exit(main(sys.argv))
